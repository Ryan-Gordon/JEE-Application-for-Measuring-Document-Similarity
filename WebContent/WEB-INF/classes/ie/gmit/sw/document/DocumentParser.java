package ie.gmit.sw.document;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;
/**
 * DocumentParser is a class used to manipulate documents to get their word contents, hashes or jaccard index.
 * @author ryangordon
 *
 */
public class DocumentParser {
	private int minHash = Integer.MAX_VALUE;
    private boolean alreadyExist = false;

    /**
     * Takes in a param of a BufferedReader and parses it to get the words.
     * @param document File submitted to UploadHandler servlet
     * @return A TreeSet of words
     * @throws IOException
     */
    public Set<String> getWords(BufferedReader document) throws IOException {
	String line;
	Set<String> allWords = new TreeSet<>();
	while ((line = document.readLine()) != null) {
	    allWords.addAll(new ArrayList<String>(Arrays.asList(line.split(" "))));
	}
	return allWords;
    }
    
    /**
     * Take in a set of words, build them into shingles and store the hashcodes in an Set.
     * @param wordsSet Set of words to be Shingle'd
     * @param shingleSize Integer. Number of words per shingle. 
     * @return Set of hash codes for all shingles
     */
    public Set<Integer> getHashes(Set<String> wordsSet, int shingleSize) {
	minHash = Integer.MAX_VALUE;
	
	StringBuilder shingleBuilder = new StringBuilder();
	int shingleCount = 0;
	
	Set<Integer> shingleHashCodes = new TreeSet<>();
	//Iterate over the words
	for (String word : wordsSet) {
	    shingleBuilder = shingleBuilder.append(word);
	     
	    if(shingleCount == shingleSize) {
	    		String shingle = shingleBuilder.toString();
	    		int hashCode = shingle.hashCode();
	    		shingleHashCodes.add(hashCode);
		if (minHash > hashCode) minHash = hashCode;
			shingleCount = 0;
			shingleBuilder = new StringBuilder();
	    } else {
	    		shingleCount++;
	    }
	}
	return shingleHashCodes;
    }

    /**
     * Creates a Set of random integers used later for XOR hashFunctions
     * @param numOfHashes HashFunctions. Size of minHash values, minus 1 that is generated by .hashCode function inside getHashes()
     * @return Set of random Integers.
     */
    public Set<Integer> getHashFunctions(int numOfHashes) {
	Set<Integer> hashFunctions = new TreeSet<Integer>();
	Random random = new Random();
	for (int i = 1; i < numOfHashes; i++) // Shingles size minus nimHash from .hashCode function.
	{
	    hashFunctions.add(random.nextInt());
	}
	return hashFunctions;
    }

    
    public int getMinHash() {
	return minHash;
    }
    
    /**
     * Takes in a document and the previously stored documents and attempts to compare them.
     * 
     * The provided document will be compared against each document in the List and will be given a similarity score
     * Results will be processed and returned.
     * @param document
     * @param documents
     * @return Map of results 
     */
    public HashMap<String, String> compareDocument(Document document, List<Document> documents) {
    	
    	//HashMap to hold our results
	HashMap<String, String> results = new HashMap<>();
	int hashFunctionsCount = document.getHashFunctionsSize();
	//Iterate over our list of documents
	alreadyExist=false;
	for (Document doc : documents) {
	    Set<Integer> retainAll = new TreeSet<>(document.getMinHashes());
	    retainAll.retainAll(doc.getMinHashes());
	    //Computer the similarity
	    double similarity = (double) retainAll.size() / hashFunctionsCount * 100;
	    //If this is true, the document is likely already saved. Flag this so it  wont be saved.
	    if (similarity == 100.0 && document.getTitle().equals(doc.getTitle()))
			alreadyExist = true;
	    results.put(doc.getTitle(), String.valueOf(similarity));
	}
	return results;
    }

    /**
     * Generate a Set of Integers which contain the hash codes with min value for every XOR operation,
     * 
     * @param hashes Set of integers/hash codes for every word in the document
     * @param hashFunctions Randomly generated integers. MUST be same for every document for the comparing to work.
     * @return Set of Integers, the hash code representation of the document. This is how document content is stored.
     */
    public Set<Integer> getMinHashes(Set<Integer> hashes, Set<Integer> hashFunctions) {
	Set<Integer> minHashes = new TreeSet<>();
	for (int hashFunction : hashFunctions) {
	    int min = Integer.MAX_VALUE;
	    //Iterate over our set of documents
	    for (Integer hash : hashes) {
		int minHash = hash ^ hashFunction; // Bitwise XOR the word hashCode with the hashFunction
		if (minHash < min)
		    min = minHash;
	    }
	    minHashes.add(min); // Only store the word with the minimum hash value for each hash function
	}
	return minHashes;
    }

    /**
     * When comparing document against the rest of documents, boolean is turned true, if document has a counterpart
     * with the same name and 100 % similarity already stored inside database. This is to prevent storing duplicate documents.
     * @return Boolean that indicates if uploaded document with the same name and 100% similarity is already stored in database.
     */
    public boolean isAlreadySaved() {
	return alreadyExist;
    }
}



